// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
int length;

float3 alphaBall;
float gravity;
float borderForceMagnitude;
float friction;

float2 xPosRange;
float2 yPosRange;
float2 zPosRange;


RWStructuredBuffer<float3> resultBuff;
RWStructuredBuffer<float3> accelerationBuff;
RWStructuredBuffer<float3> velocityBuff;
RWStructuredBuffer<float3> positionBuff;
RWStructuredBuffer<float> massBuff;




float3 calculateForces(uint id)
{
	float3 allForces = float3(0,0,0);
	float dist;
	float maxDist;
	float3 minusPositions;


	for (int i = 0; i < length; i++)
	{
		minusPositions = positionBuff[id.x] - positionBuff[i];
		dist = dot(minusPositions, minusPositions);
		maxDist = (massBuff[id.x] * massBuff[id.x] + massBuff[i] * massBuff[i]) / 4;

			if (dist < maxDist && dist != 0)
			{
				allForces += normalize(minusPositions)/10; // * (dist/maxDist);
			}
	}

	if (positionBuff[id.x].x < xPosRange.x)
		allForces.x += borderForceMagnitude;
	else if (positionBuff[id.x].x > xPosRange.y)
		allForces.x -= borderForceMagnitude;

	if (positionBuff[id.x].z < zPosRange.x)
		allForces.z += borderForceMagnitude;
	else if (positionBuff[id.x].z > zPosRange.y)
		allForces.z -= borderForceMagnitude;

	float velDot = dot(velocityBuff[id.x], velocityBuff[id.x]);

	if (velDot != 0)
    {
	float3 frictionVec = -velocityBuff[id.x] / sqrt(velDot);
	frictionVec *= friction;
	allForces += frictionVec;
	}

	return allForces;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	
	accelerationBuff[id.x] = float3(0, gravity, 0);
	accelerationBuff[id.x] += calculateForces(id) / massBuff[id.x];

	//if (dot(velocityBuff[id.x], velocityBuff[id.x]) < 0.00005)
	//	accelerationBuff[id.x] = 0;

	velocityBuff[id.x] += accelerationBuff[id.x];

	

	float3 newPosition = positionBuff[id.x] + velocityBuff[id.x];

	if (newPosition.y < yPosRange.x)
	{ 
		velocityBuff[id.x].y = abs(velocityBuff[id.x].y);
		newPosition = positionBuff[id.x] + velocityBuff[id.x];
		newPosition.y = yPosRange.x;
	}


	resultBuff[id.x] = newPosition;



}




